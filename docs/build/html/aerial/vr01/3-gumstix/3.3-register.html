

<!DOCTYPE html>
<html class="writer-html5" lang="en,pt-BR" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Registers &mdash; CoopRobo 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Comunicação Serial" href="3.4-Serial.html" />
    <link rel="prev" title="Cross-compilation" href="3.2-CrossCompilation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> CoopRobo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Robots</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../aerial.html">Aerial Robots</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../vr01.html">VR-01</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../1-autopilot/1.0-pilot.html">Autopilot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1-autopilot/1.1-config_pilot.html">Autopilot Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2-embedded_system/2.0-embedded_system.html">Embedded System</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="3.0-intro.html">Using the embedded computer</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="3.1-Ambient_Linux.html">Getting used to Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="3.2-CrossCompilation.html">Cross-compilation</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="3.4-Serial.html">Comunicação Serial</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../vr01.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile.html">Mobile Robots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manipulators.html">Manipulators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs-ref.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../camera.html">Camera</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CoopRobo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../aerial.html">Aerial Robots</a> &raquo;</li>
        
          <li><a href="../../vr01.html">VR-01</a> &raquo;</li>
        
          <li><a href="3.0-intro.html">Using the embedded computer</a> &raquo;</li>
        
      <li>Registers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/aerial/vr01/3-gumstix/3.3-register.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="registers">
<h1>Registers<a class="headerlink" href="#registers" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Este tópico precisa ser testado e reeditado.</p>
</div>
<p>Following the procedures of the previous sections we are able to start the system and generate programs to be executed by the operating system. The next step, therefore, is to control the signals that can be sent to other devices by the embedded computer to establish communication between the devices.</p>
<p>Communication between devices is done by changing the voltage levels of the embedded computer's pins. These pins are, in summary fashion, connected to <strong>system memory space</strong> and, when we change the bit stored in this memory space, also changed the pin voltage level, allowing the encoding of a message and its transmission to another device.</p>
<p>Subsequently, the communication between devices will be more discussed, but at this moment what most matters to us are the <strong>memory spaces</strong>, mentioned in the previous paragraph. These memory spaces are actually volatile digital circuits that are capable os stoting voltage levels, the acess to the contents of these memory spaces is extremely fast and these memory spaces are called <strong>register</strong>. <strong>Registers</strong> are at the top of the memory hierarchy, making them the fastest type of memory in a central processing unit.</p>
<p>So, in order to implement communication between two devices, a modem and the embedded computer, for example, we first need to perform a simpler task of changing the voltage levels of a pin. This process of changing the voltage levels of a pin has several applications, ranging from simple ON / OFF control of an LED to serial communication between devices. Pins for this purpose are called <a class="reference external" href="https://en.wikipedia.org/wiki/General-purpose_input/output">General Purpose Input/Output</a> (<strong>GPIO</strong>).</p>
<p><strong>General Purpose Input/Output</strong> (<strong>GPIO</strong>) are, basically, communication pins for input and output of digital signals, of an integrated circuit or electronic circuit board, with no pre-defined purpose, thus being able to have functions defined by the designer or user to provide an interface between other devices (peripherals, modems, microcontrollers, microprocessors, etc.).</p>
<p>As previously mentioned, we are using the Overo embedded computer next to a Tobi expansion board. One of the functions of Tobi board is to provide user access to the pins of the embedded computer, so the pins of the embedded computer that we can access physically are the pins of the Tobi expansion board. In the figure below we can see a diagram that contains, in summary form, which functions or pins of the embedded computer are connected to each pin of the Tobi expansion board. Note that some of these pins have more than one function.</p>
<div class="figure align-center" id="id2">
<img alt="../../../_images/Pinos_Tobi.png" src="../../../_images/Pinos_Tobi.png" />
<p class="caption"><span class="caption-text">Tobi expansion board pin diagram.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="gpio-control-via-terminal">
<h2>GPIO control via terminal<a class="headerlink" href="#gpio-control-via-terminal" title="Permalink to this headline">¶</a></h2>
<p>The simplest, but least efficient way to control the GPIO is described on the manufacturer's own website, available at <a class="reference external" href="https://www.gumstix.com/support/faq/overo-gpio/#cross-compilation">Control Overo GPIO</a>. They indicate to control the GPIO by the Linux system terminal itself through a <em>sysfs system</em>. The <em>sysfs system</em> is a system of files offered by the Linux kernel for control and communication with devices and drivers through the Linux terminal.</p>
<p>If, for example, we want to control <strong>GPIO10</strong> output using this method to flash an LED, we need to export <strong>GPIO10</strong> to the user space by typing <code class="docutils literal notranslate"><span class="pre">10</span></code> in the file <em>/sys/class/gpio/export</em>, which will generate a directory with other files for <strong>GPIO10</strong> manipulation. Next, we must define its direction as outgoing by writing <code class="docutils literal notranslate"><span class="pre">out</span></code> in <em>/sys/class/gpio/gpio10/direction</em> and define its value as high or low by writing <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> in <em>/sys/class/gpio/gpio10/value</em>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The interrupt configuration function is also accessible from the terminal.</p>
</div>
<p>This process can be done by the user's terminal with the command <code class="docutils literal notranslate"><span class="pre">echo</span></code>, or by a program that opens this file and writes to it for us. For example, to control <strong>GPIO146</strong> via the terminal, we can execute the following commands (example used on the Gumstix website):</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remembering that the command <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">test</span> <span class="pre">&gt;</span> <span class="pre">folder/file</span></code> will overwrite the entire file with the word 'test' and the command <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">folder/file</span></code> will display the contents of the file.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo 146 &gt; /sys/class/gpio/export</span>
<span class="n">root</span><span class="nd">@overo</span><span class="p">:</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">class</span><span class="o">/</span><span class="n">gpio</span><span class="c1"># cat gpio146/direction</span>
<span class="ow">in</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo out &gt; /sys/class/gpio/gpio146/direction</span>
<span class="n">root</span><span class="nd">@overo</span><span class="p">:</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">class</span><span class="o">/</span><span class="n">gpio</span><span class="c1"># cat gpio146/direction</span>
<span class="n">out</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># cat /sys/class/gpio/gpio146/value</span>
<span class="mi">0</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo 1 &gt; /sys/class/gpio/gpio146/value</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># cat /sys/class/gpio/gpio146/value</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>This command will control pin 27 on the Tobi board.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you don't have a meter, a 1.8V LED can be used. Use pin 1 as the ground.</p>
</div>
<p>However, as already mentioned, this method is very slow and cannot be used for communication between devices. Thought, for activities over 100 milliseconds, this method can be used smoothly.</p>
<p>Another approach, using the same method, is to use code similar to the code shown below, which writes directly to <strong>GPIO</strong> files. This approach has been tested and has considerably improved, through a simple code, the GPIO response time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>
<span class="c1">#include &lt;fcntl.h&gt;</span>
<span class="c1">#include &lt;termios.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/export&quot;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/gpio10/direction&quot;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/gpio10/value&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span> <span class="p">(</span><span class="mi">500000</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span> <span class="p">(</span><span class="mi">500000</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference download internal" download="" href="../../../_downloads/f890b0dc5a279b64838d46b88993c227/t1-gpio.c"><code class="xref download docutils literal notranslate"><span class="pre">Downloaded</span> <span class="pre">commented</span> <span class="pre">code</span> <span class="pre">1</span></code></a></p>
<p>To test the code, pin 18 (<strong>GPIO</strong> pin 10) was connected to an oscilloscope in order to measure the period of the waveform. The result of this measurement can be seen in the figure below, in which we can see the amplitude of the wave form of 1.96 V, frequency of 33.76 kHz and period of 29.62 microseconds. For most applications we can use this method.</p>
<div class="figure align-center">
<img alt="../../../_images/teste1-gpio.png" src="../../../_images/teste1-gpio.png" />
</div>
</div>
<div class="section" id="gpio-control-via-registers">
<h2>GPIO control via registers<a class="headerlink" href="#gpio-control-via-registers" title="Permalink to this headline">¶</a></h2>
<p>Another way to control the GPIO is to write directly to the system registers. Although the procedure is a little more complex, this is actually the most common and recommended way to perform this procedure, offering much faster results.</p>
<p>To use this method, we first need to define which registers to write to and what to write to. This information can only be found at <a class="reference download internal" download="" href="../../../_downloads/478aee14d85d8b9ee0d031e35242bb99/TRM_DM3730.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Technical</span> <span class="pre">Reference</span> <span class="pre">Manual</span> <span class="pre">(TRM)</span></code></a> of the DM3730 processor, available on the <a class="reference external" href="https://www.ti.com/">Texas Instruments</a> website.</p>
<p>As explained in section <strong>25</strong> of the DM3730 processor TRM, starting on page 3477, the control interface combines six GPIO banks. Each GPIO module provides 32 pins, totaling 192 pins that can be used as input and/or output. In our case, only some of these 192 pins are physically accessible, as can be seen in the figure shown below. Each GPIO bank has 26 registers distributed from a base address, each register having a length of 32 bits or 4 bytes.</p>
<div class="figure align-center" id="id3">
<img alt="../../../_images/interface-gpio.png" src="../../../_images/interface-gpio.png" />
<p class="caption"><span class="caption-text">Diagram of the GPIO interface.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The figure was taken from the Technical Reference Manual of the DM3730 processor and shows a little more detail how these pins are distributed among the GPIO modules. A detailed explanation of each of these registers can be found in the DM3730 processor manual.</p>
</div>
<p>In this work, only two of the registers will be commented in order to illustrate the functioning of these registers.</p>
<p>The register <strong>GPIO_OE</strong> is the register that defines the direction of the pin being configured. The abbreviation &quot;OE&quot; comes from &quot;Output Enable&quot;. This register has an address offset equal to &quot;0x034&quot;, that is, its address will be the base address of the GPIO module plus 34 in hexadecimal. This register has 32 bits of type &quot;Read/White&quot;, or so, if the pin corresponding to the GPIO port is storing the value <strong>0</strong>, this GPIO port will be configured to operate as an output, if this pin is the value <strong>1</strong> the port will be configured as an input.</p>
<p>The register <strong>GPIO_SETDATAOUT</strong> is the register that has the function of setting the bit corresponding to the register <strong>GPIO_DATAOUT</strong> to 1. That is, if everything is set correctly, the voltage value equivalent to bit 1 will appear on the physical pin. This register has an offset address equal to &quot;0x094&quot;. Like the register mentioned above, this register consists of 32 bits of type &quot;RW&quot;. Reading any of the bits in this register returns the value of the corresponding bit in <strong>GPIO_DATAOUT</strong>.</p>
<p>In addition to the registers shown in section 25 of the Technical Reference Manual, it's also necessary to configure a register for the <strong>System Control Module</strong> (<strong>SCM</strong>). SCM is a module that allows control through software of various functions of the device. For our application, the SCM is the primary control point for the GPIO function and it is where we will perform the multiplexing, which determines whether the pin will operate in the GPIO function or in its specific function, and we will define whether the GPIO will be of the type pullup or pulldown, for example.</p>
<p>SCM registrars are divided into five classes. However, for our application we will use only one, the block of configuration and multiplexing registers. This block is a set of 32-bit registers, which configures 2 pins and defines, in addition to the two parameters mentioned above, the <strong>wakeup</strong> function. Registrars belonging to this block are called <strong>Configuration Register Functionality</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More information about SCM can be found in section 13 of the Technical Reference Manual.</p>
</div>
<p>To find the address of each register of this type we can look in table 13-4 of the TRM. This table will be given the exact physical address of each register (base + offset). In this case, the base address is the address of the &quot;PADCONFS&quot; registers of the SCM interface, found in section 13.6.1 of the TRM and the offset address of each register in this block can be found in table 13-73 of the same document.</p>
<p>After the identification of the registrars, we can start the elaboration of a code to modify them. So we face yet another challenge, operating systems work with two concepts of memory, physical memory and virtual memory. Physical memory is the memory of the hardware, the one that we know the address and because we checked in the TRM. However, if we create a pointer that points to the memory &quot;0x4800000&quot;, for example, it will not point to the physical memory that has this address because the operating system maps a different physical memory space for each program with the main objectives of increasing the security and avoid data conflicts between programs.</p>
<p>However, to have access to the physical memory of the system, we need to ask the operating system to map this memory space to the application. One way to do this is through the ´´mmap ()´´ function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Details on how this function works and its parameters can be found at <a class="reference external" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2) — Linux manual page</a>.</p>
</div>
<p>Let's assume that we want to map the physical memory space from <strong>0x45000000</strong> to <strong>0x45001000</strong> and for that we decided to use the <code class="docutils literal notranslate"><span class="pre">mmap</span> <span class="pre">()</span></code> function. Therefore, we call the function as follows, for example, <code class="docutils literal notranslate"><span class="pre">mmap(NULL,0x1000,PROT_WRITE</span> <span class="pre">||</span> <span class="pre">PROT_READ,MAP_SHARED,fd,0x45000000)</span></code>, by executing this the function will return a pointer that points to a virtual memory address addressed to the physical memory address <strong>0x45000000</strong>. Where, to access the physical memory of the device, &quot;<strong>fd</strong>&quot; is the <strong>file descriptor</strong> directed to &quot;/dev/mem&quot;.</p>
<p>With this information, we have everything that is necessary to implement tests on this operating mode. Below is a code that applies the method described in this section to toggle the voltage level of pin <strong>186</strong>. This code was implemented to perform the same test as the section &quot;GPIO control via terminal&quot;.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code below was obtained from the <a class="reference external" href="http://gumstix.8.x6.nabble.com/Direct-register-access-control-of-GPIO-ARM-interface-on-Overo-Water-TOBI-SOLVED-td4965117.html">Gumstix Discussion Forum</a> and minor changes were made to avoid excessive information and facilitate its understanding.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Local</span> <span class="n">includes</span> <span class="n">definition</span>
<span class="c1">#include &lt;stdio.h&gt;    // for lprint instruction</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;fcntl.h&gt;    // ok for mmap</span>
<span class="c1">#include &lt;sys/mman.h&gt; // ok for mmap</span>
<span class="c1">#include &lt;unistd.h&gt;</span>

<span class="o">//</span> <span class="n">Defines</span> <span class="n">local</span> <span class="n">parameters</span> <span class="p">(</span><span class="kn">from</span> <span class="nn">TRM</span><span class="p">)</span>
<span class="c1">#define SCM_INTERFACE_BASE 0x48002000</span>
<span class="c1">#define SCM_PADCONFS_BASE 0x48002030</span>
<span class="c1">#define CONTROL_PADCONF_SYS_NIRQ (*(volatile unsigned long *)0x480021E0)</span>
<span class="c1">#define CONTROL_PADCONF_SYS_NIRQ_OFFSET 0x1B0</span>

<span class="c1">#define GPIO6_BASE 0x49058000</span>
<span class="c1">#define GPIO6_SYSCONFIG_OFFSET 0x10</span>
<span class="c1">#define GPIO6_CLEARDATAOUT_OFFSET 0x90</span>
<span class="c1">#define GPIO6_SETDATAOUT_OFFSET 0x94</span>
<span class="c1">#define GPIO6_OE_OFFSET 0x34</span>
<span class="c1">#define GPIO6_CTRL_OFFSET 0x30</span>

<span class="c1">#define MAP_SIZE (volatile unsigned long)4 * 1024</span>
<span class="c1">#define MAP_MASK (volatile unsigned long)(MAP_SIZE - 1)</span>

<span class="o">//</span> <span class="n">Defines</span> <span class="s2">&quot;volatile unsigned long&quot;</span> <span class="n">how</span> <span class="s2">&quot;u32&quot;</span>
<span class="c1">#define u32 volatile unsigned long</span>

<span class="o">//</span> <span class="n">Defines</span> <span class="n">commom</span> <span class="n">variables</span>
<span class="n">u32</span> <span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">u32</span> <span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="o">//</span> <span class="n">Local</span> <span class="n">functions</span> <span class="n">definition</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Defines</span> <span class="n">local</span> <span class="n">variables</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">i</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/mem&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span> <span class="o">//</span> <span class="s2">&quot;O_RDWR&quot;</span> <span class="n">opens</span> <span class="n">the</span> <span class="n">file</span> <span class="k">for</span> <span class="n">reading</span> <span class="ow">and</span> <span class="n">writing</span> <span class="o">&amp;</span> <span class="s2">&quot;O_SYNC&quot;</span> <span class="n">guarantees</span> <span class="n">that</span> <span class="n">the</span> <span class="n">call</span> <span class="n">will</span> <span class="ow">not</span> <span class="k">return</span> <span class="n">before</span> <span class="nb">all</span> <span class="n">data</span> <span class="n">has</span> <span class="n">been</span> <span class="n">transferred</span> <span class="n">to</span> <span class="n">the</span> <span class="n">disk</span>

    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">SCM_INTERFACE_BASE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAP_MASK</span><span class="p">);</span> <span class="o">//</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">new</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">virtual</span> <span class="n">address</span> <span class="n">space</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">A</span> <span class="o">+</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="n">CONTROL_PADCONF_SYS_NIRQ_OFFSET</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x00040000</span><span class="p">);</span> <span class="o">//</span><span class="nb">set</span> <span class="n">mode</span> <span class="mi">4</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pad</span> <span class="mi">186</span> <span class="n">configuration</span> <span class="n">register</span><span class="p">;</span> <span class="n">enables</span> <span class="n">digital</span> <span class="n">pin</span> <span class="n">use</span>

    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="o">/********/</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/mem&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span>

    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">volatile</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">GPIO6_BASE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAP_MASK</span><span class="p">);</span> <span class="o">//</span> <span class="n">COM1</span> <span class="mh">0x4806A000</span>

    <span class="o">//</span><span class="n">gpio_186</span> <span class="n">handling</span>
    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_SYSCONFIG_OFFSET</span><span class="p">)</span> <span class="o">|=</span> <span class="mh">0x00000004</span><span class="p">;</span> <span class="o">//</span> <span class="n">bit2</span><span class="o">=</span><span class="mi">1</span> <span class="n">enable</span><span class="o">/</span><span class="n">wake</span> <span class="n">up</span><span class="p">,</span> <span class="n">free</span> <span class="n">running</span> <span class="n">clock</span>

    <span class="o">//*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_CTRL_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xfffffffe</span><span class="p">;</span> <span class="o">//</span> <span class="n">bit0</span><span class="o">=</span><span class="mi">0</span> <span class="n">module</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">clock</span> <span class="ow">not</span> <span class="n">gated</span> <span class="p">,</span> <span class="n">clock</span><span class="o">=</span><span class="n">interface</span> <span class="n">clock</span> <span class="n">divided</span> <span class="n">by</span> <span class="mi">8</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span><span class="o">+</span><span class="n">GPIO6_CTRL_OFFSET</span><span class="p">)</span><span class="o">&amp;=</span> <span class="mh">0xfffffff8</span><span class="p">;</span>  <span class="o">//</span> <span class="n">bit0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">bit1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">bit2</span><span class="o">=</span><span class="mi">0</span> <span class="n">module</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">clock</span> <span class="ow">not</span> <span class="n">gated</span> <span class="p">,</span> <span class="n">clock</span><span class="o">=</span><span class="n">interface</span> <span class="n">clock</span> <span class="ow">not</span> <span class="n">divided</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_OE_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xfbffffff</span><span class="p">;</span> <span class="o">//</span> <span class="n">bit26</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">gpio_186</span> <span class="n">output</span>

    <span class="o">//</span> <span class="n">generate</span> <span class="n">a</span> <span class="n">pulse</span> <span class="n">stream</span> <span class="n">on</span> <span class="n">gpio_186</span> <span class="n">pin</span> <span class="n">output</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">GPIO6_CLEARDATAOUT_OFFSET</span><span class="p">))</span> <span class="o">|=</span> <span class="mh">0x04000000</span><span class="p">;</span>
        <span class="o">//</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Saida = 0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>


        <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">GPIO6_SETDATAOUT_OFFSET</span><span class="p">))</span> <span class="o">|=</span> <span class="mh">0x04000000</span><span class="p">;</span>
        <span class="o">//</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Saida = 1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference download internal" download="" href="../../../_downloads/b99690df20e7c56a3d7f1eb3eb9f091b/t2-fusao.c"><code class="xref download docutils literal notranslate"><span class="pre">Downloaded</span> <span class="pre">commented</span> <span class="pre">code</span> <span class="pre">2</span></code></a></p>
<p>The code above was tested in the same way as the code presented in the previous section. In the following figure, you can see the result of this test. Note that the time obtained was 720.3 nanoseconds, that is, approximately 42 times faster than the result of the other method. Moreover, we can observe that the waveform is no longer an exact rectangular signal, the presence of a capacitive effect slowing the process is evident, therefore, it is possible that this is the maximum speed at which the signal of a pin can be changed .</p>
<p>Very hardly any application involving GPIO will not be satisfied by any of the methods presented here.</p>
<div class="section" id="problems-writing-to-registers">
<h3>Problems writing to registers<a class="headerlink" href="#problems-writing-to-registers" title="Permalink to this headline">¶</a></h3>
<p>To conclude this last topic, it is necessary to highlight some recently encountered problems involving writing in registers.</p>
<p>The first problem encountered occurs whenever we try to change the value of registers &quot;<strong>0x49050030</strong>&quot;, &quot;<strong>0x49056030</strong>&quot; and &quot;<strong>0x49058030</strong>&quot;, responsible for controlling the clock of the entire block of &quot;<strong>GPIO_2</strong>&quot;,&quot;<strong>GPIO_5</strong>&quot; and &quot;<strong>GPIO_6</strong>&quot;, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">devmem2</span></code> is a command that executes a simple program to read or write in any memory space. More information can be found in <a class="reference external" href="http://manpages.ubuntu.com/manpages/focal/man1/devmem2.1.html#name">devmem2 - Ubuntu Manual</a>.</p>
</div>
<p>What happens is that moments after changing the value of the register, its returns the value it had before being changed. As the test in this section had a very high frequency, it was not interrupted by this effect, but the phenomenon occurs even when we change values of the registers by terminal commands, such as <code class="docutils literal notranslate"><span class="pre">devmem2</span></code>. This problem is exemplified in the figure below, where we execute the command <code class="docutils literal notranslate"><span class="pre">devmem2</span> <span class="pre">0x49058030</span> <span class="pre">w</span> <span class="pre">0x2</span></code> to modify the register <strong>0x49058030</strong> which is the register that controls the clock of the entire <strong>GPIO_6</strong> block.</p>
<div class="figure align-center">
<img alt="../../../_images/register-erro.png" src="../../../_images/register-erro.png" />
</div>
<p>Such modification should reduce the clock speed by dividing it by 2, as indicated in the Technical Reference Manual (TRM) of the DM3730 processor, in table 25-29, page 3528, where it is explained that the <strong>GPIO_CTRL</strong> may have its clock divided by certain pre-registered values, as shown in the following figure.</p>
<div class="figure align-center">
<img alt="../../../_images/GPIO_CTRL.png" src="../../../_images/GPIO_CTRL.png" />
</div>
<p>Porém, logo após a execução do comando é realizado um procedimento de leitura que garante que tudo foi escrito no registrador como o esperado. No entanto, o mesmo comando, executado instantes depois no modo de leitura, retorna um valor nulo no registrador. No caso o valor existente no registrador antes da modificação era nulo, porém o registrador sempre retorna ao valor anteriormente armazenado. Vale ressaltar que este problema não ocorre para o método de controle do GPIO via terminal, este método opera até que receba uma ordem de parada do usuário.</p>
<p>O segundo problema encontrado ocorre quando tentamos alterar o valor dos registradores <strong>0x49052030</strong> e <strong>0x49054030</strong>, responsáveis por controlar o clock de todo o bloco do <strong>GPIO_3</strong> e do <strong>GPIO_4</strong>, respectivamente. Nesses registradores em específico, ao tentar executar o comando <code class="docutils literal notranslate"><span class="pre">devmem2</span></code> para alterar o clock de um determinado bloco de GPIO ou apenas realizar uma leitura, o sistema retorna o erro &quot;<em>bus error</em>&quot; como apresentado na figura abaixo, onde executamos o mesmo comando no registrador <strong>0x</strong>.</p>
<div class="figure align-center">
<img alt="../../../_images/register-bus_erro.png" src="../../../_images/register-bus_erro.png" />
</div>
<p>Dessa forma, foi possível apenas alterar o clock do bloco do <strong>GPIO_1</strong>, como pode ser visto na imagem abaixo.</p>
<div class="figure align-center">
<img alt="../../../_images/register-clock.png" src="../../../_images/register-clock.png" />
</div>
<p>Não sabemos por quais motivos esses fenômenos estão ocorrendo com os blocos de 2 a 6, porém suspeitasse que alguns processos do sistema operacional estejam impedindo que o clock de tais blocos seja alterados, provavelmente por algum circuito interno ou operação depende de tais valores pré-definidos ou até por alguma restrição no consumo de energia.</p>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>PITA, H. C. Desenvolvimento de sistema de comunicação multiplataforma para veículos aéreos de asa fixa. Faculdade de Tecnologia, Universidade de Brasília, 2018.</p></li>
<li><p>TEXAS INSTRUMENTS. AM/DM37x Multimedia Device Technical Reference Manual. 12500 TI Blvd, Dallas, TX 75243, EUA, 2012. Version R. Disponível em: <a class="reference external" href="http://www.ti.com/">ti.com</a>.</p></li>
<li><p>Direct register access control of GPIO ARM interface on Overo Water +TOBI - <a class="reference external" href="http://gumstix.8.x6.nabble.com/Direct-register-access-control-of-GPIO-ARM-interface-on-Overo-Water-TOBI-SOLVED-td4965117.html">Gumstix Discussion Forum</a></p></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="3.4-Serial.html" class="btn btn-neutral float-right" title="Comunicação Serial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="3.2-CrossCompilation.html" class="btn btn-neutral float-left" title="Cross-compilation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Gabriel Araujo

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>